<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessaly Cartography ‚Äì Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

<!-- ============================================================
     EXTERNAL LIBRARIES - MAPLIBRE GL
     ============================================================
     MapLibre GL is an open-source library for displaying interactive maps
     We need both the CSS (for styling) and JavaScript (for functionality)
     ============================================================ -->

<!--
MapLibre GL CSS
- Provides the visual styling for the map
- Styles map controls (zoom buttons, attribution, scale bar)
- Ensures correct layout and appearance of the map canvas
-->
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />

<!--
MapLibre GL JavaScript
- Core MapLibre library for web mapping
- Handles map rendering using WebGL
- Enables interaction (zoom, pan, rotation)
- Supports loading layers, GeoJSON data, and user events
-->
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<!-- ============================================================
     CSS STYLING SECTION
     ============================================================
     This <style> section contains all the visual styling rules for:
     - Map container layout
     - Control panels (left side)
     - Legend (top right) 
     - Buttons, sliders, and other UI elements
     
     Students: You generally don't need to modify CSS unless you want
     to change the appearance of the interface itself
     ============================================================ -->
<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }

  #styleSelector {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 6px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.25);
  }

  #controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 10px;
    font-size: 13px;
    border-radius: 6px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  }
  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 6;
    background: white;
    padding: 18px;
    font-size: 13px;
    border-radius: 6px;
    max-width: 360px;
    max-height: 85vh;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    display: none;
    resize: both;
    overflow: auto;
    min-width: 200px;
    min-height: 100px;
  }
  
  /* üåç STUDENTS - MODIFY HEADER STYLES: Change title/subtitle/author font sizes and colors here */
  .legend-header {
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #333;
  }
  .legend-map-title {
    font-size: 15px; /* üåç STUDENTS: Adjust size for main title */
    font-weight: 700;
    color: #000; /* üåç STUDENTS: Change hex code for different title color */
    margin-bottom: 10px;
    line-height: 1.4;
    text-align: center;
  }
  .legend-subtitle {
    font-size: 11px; /* üåç STUDENTS: Adjust size for subtitle */
    font-style: italic;
    color: #333; /* üåç STUDENTS: Change subtitle color */
    margin-bottom: 10px;
    line-height: 1.3;
    text-align: center;
  }
  .legend-author {
    font-size: 10px; /* üåç STUDENTS: Adjust size for author information */
    color: #555; /* üåç STUDENTS: Change author text color */
    line-height: 1.4;
    text-align: left;
  }
  .legend-author strong {
    font-weight: 700;
  }
  
  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
<!-- ============================================================
     END OF CSS STYLING SECTION
     ============================================================ -->
</head>
<body>

<!-- ============================================================
     HTML STRUCTURE SECTION - USER INTERFACE ELEMENTS
     ============================================================
     This section defines the visual interface that users interact with:
     - Basemap selector (Light/Dark)
     - Layer checkboxes and controls (left panel)
     - Legend (right panel, dynamically updated by JavaScript)
     - Map container (fills the entire background)
     ============================================================ -->

<!-- Basemap selector dropdown (Light or Dark background map) -->
<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>
</div>

<!-- Layer controls panel (left side of screen) -->
<div id="controls">
  <strong>Layers</strong><br><br>

  <!-- Layer 1: Population Density Choropleth Map -->
  <input type="checkbox" id="popdensToggle"> <strong>Population Density (Choropleth Map)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Classification method:
      <select id="classificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">üåç Custom intervals</option>
      </select>
    </label>
    <label id="numClassesLabel">Number of classes:
      <select id="numClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="popdensOpacityLabel" class="control-value">60%</span>
      <input type="range" id="popdensOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <!-- Layer 2: Population Density Dasymmetric Map -->
  <input type="checkbox" id="denscoverToggle"> <strong>Population Density (Dasymmetric Map)</strong><br>
  <div class="layer-controls" id="denscoverControls">
    <label>Classification method:
      <select id="denscoverClassificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">üåç Custom intervals</option>
      </select>
    </label>
    <label id="denscoverNumClassesLabel">Number of classes:
      <select id="denscoverNumClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="denscoverOpacityLabel" class="control-value">60%</span>
      <input type="range" id="denscoverOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <!-- Layer 3: Population Proportional Symbols -->
  <input type="checkbox" id="poipopToggle"> <strong>Population (Proportional symbols)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Maximum circle radius (px): <span id="maxRadiusLabel" class="control-value">70</span>
      <input type="range" id="maxRadius" min="20" max="200" value="70">
    </label>
    <label>Opacity (circles): <span id="poipopOpacityLabel" class="control-value">25%</span>
      <input type="range" id="poipopOpacity" min="0" max="100" value="25">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      <strong>Note (students):</strong> Flannery scaling is used for perceptual equality.
    </small>
  </div>
  <hr>

  <!-- Layer 4: Population Dynamic Contours (Isopleths) -->
  <input type="checkbox" id="contoursToggle"> <strong>Population dynamic (Isopleths map)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity (contours): <span id="contoursOpacityLabel" class="control-value">80%</span>
      <input type="range" id="contoursOpacity" min="0" max="100" value="80">
    </label>
  </div>
  <hr>

  <!-- Layer 5: Population Dot Map -->
  <input type="checkbox" id="dotsToggle"> <strong>Population (Dot map)</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Dot size (px): <span id="dotSizeLabel" class="control-value">1.9</span>
      <input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="1.9">
    </label>
    <label>Opacity (dots): <span id="dotsOpacityLabel" class="control-value">100%</span>
      <input type="range" id="dotsOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Layer 6: Municipal Boundaries -->
  <input type="checkbox" id="boundariesToggle"> <strong>Municipal boundaries</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity (boundaries): <span id="boundariesOpacityLabel" class="control-value">100%</span>
      <input type="range" id="boundariesOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Data notes for students -->
  <div style="font-size:12px;color:#555">
    <strong>Data notes (students)</strong><br>
    - All GeoJSONs expected in <code>data/</code> folder<br>
    - Fields: <code>POPDENS</code>, <code>DENS_COVER</code>, <code>POPMUN</code>, <code>ID</code>
  </div>
</div>

<!-- Legend container (right side, dynamically populated by JavaScript) -->
<div id="legend"></div>

<!-- Map container (fills entire background) -->
<div id="map"></div>

<!-- ============================================================
     END OF HTML STRUCTURE SECTION
     ============================================================ -->

<!-- ============================================================
     JAVASCRIPT SECTION - APPLICATION LOGIC
     ============================================================
     This is where all the interactive functionality is defined.
     The code is organized in the following flow:
     
     1. MAP INITIALIZATION - Create the map object
     2. DATA CONFIGURATION - Define where data files are located
     3. COLOR SCHEMES - Define colors for visualizations
     4. CLASSIFICATION FUNCTIONS - Calculate class breaks
     5. LAYER LOADING FUNCTIONS - Load and display each layer
     6. LEGEND FUNCTION - Generate legend dynamically
     7. EVENT LISTENERS - Respond to user interactions
     
     Students: Focus on sections marked with üåç (mandatory changes)
     and üó∫Ô∏è (optional styling changes)
     ============================================================ -->
<script>

// ============================================================
// 1. MAP INITIALIZATION
// ============================================================
// This creates the interactive map object that will display everything

/* üåç STUDENTS - MODIFY MAP CENTER AND ZOOM */
const map = new maplibregl.Map({
  container: 'map',           // Links to the <div id="map"> element in HTML
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',  // Initial basemap style
  center: [22.4, 39.6],       // üåç STUDENTS: [longitude, latitude] for your study area
  zoom: 8                     // üåç STUDENTS: Zoom level (0=world, 20=street level)
});

// ============================================================
// 2. DATA CONFIGURATION
// ============================================================
// This object defines where each GeoJSON file is located and which
// field contains the data to visualize

/* üåç STUDENTS - MODIFY DATA FILE PATHS AND FIELD NAMES */
const layerDefinitions = {
  // Choropleth map layer (population density by municipality)
  popdens: {
    sourceId: 'popdens-src',                       // Internal ID for the data source
    layerId: 'popdens-layer',                      // Internal ID for the map layer
    url: 'data/dimoi_popdens_WGS.geojson',        // üåç STUDENTS: Path to your file
    dataField: 'POPDENS'                           // üåç STUDENTS: Column name in your GeoJSON
  },
  // Dasymmetric map layer (population density by land cover zone)
  denscover: {
    sourceId: 'denscover-src',
    layerId: 'denscover-layer',
    url: 'data/dimoi_popdens_cover_WGS.geojson',  // üåç STUDENTS: Path to your file
    dataField: 'DENS_COVER'                        // üåç STUDENTS: Column name in your GeoJSON
  },
  // Proportional symbols layer (circles sized by population)
  poipop: {
    sourceId: 'poipop-src',
    layerId: 'poipop-layer',
    url: 'data/dimoi_poi_pop_WGS.geojson',        // üåç STUDENTS: Path to your file
    dataField: 'POPMUN',                           // üåç STUDENTS: Column name in your GeoJSON
    maxValueApprox: 100000                         // üåç STUDENTS: Approximate maximum value (for scaling circles)
  },
  // Contours/isopleths layer (population potential lines)
  contours: {
    sourceId: 'contours-src',
    layerId: 'contours-layer',
    url: 'data/pop_contours_200k_WGS.geojson'     // üåç STUDENTS: Path to your file
  },
  // Dot density layer (each dot represents X people)
  dots: {
    sourceId: 'dots-src',
    layerId: 'dots-layer',
    url: 'data/pop_dots_300_WGS.geojson'          // üåç STUDENTS: Path to your file
  },
  // Boundaries layer (municipal borders)
  boundaries: {
    sourceId: 'boundaries-src',
    layerId: 'boundaries-layer',
    url: 'data/dimoi_oria_WGS.geojson'            // üåç STUDENTS: Path to your file
  }
};

// Variables to cache loaded data (so we don't reload it every time)
let popdensData = null;      // Stores choropleth data once loaded
let denscoverData = null;    // Stores dasymmetric data once loaded

// Tracks which layers are currently visible on the map
const enabledLayers = { 
  popdens: false,
  denscover: false,
  poipop: false,
  contours: false,
  dots: false,
  boundaries: false
};

// ============================================================
// 3. COLOR SCHEMES
// ============================================================
// These arrays define the colors used for each classification method
// The number of colors must match the number of classes + 1

/* üåç STUDENTS - MODIFY CHOROPLETH COLOR SCHEMES (for POPDENS layer) */
// üó∫Ô∏è Change these hex colors to customize your choropleth appearance
const colorSchemes = {
  3: ['#ffcccc', '#ff6666', '#990000'],           // 3 classes = 4 colors (lightest to darkest)
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'],
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'],  // Default
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
};

/* üåç STUDENTS - MODIFY DASYMMETRIC MAP COLOR SCHEMES (for DENS_COVER layer) */
// üó∫Ô∏è Change these hex colors (blue scheme used here to differentiate from choropleth)
const denscoverColorSchemes = {
  3: ['#d0e5f5', '#4a90c4', '#0d4a70'],
  4: ['#d0e5f5', '#7db3d8', '#2e6fa8', '#0d4a70'],
  5: ['#d0e5f5', '#9cc9e3', '#4a90c4', '#2e6fa8', '#0d4a70'],  // Default
  6: ['#d0e5f5', '#9cc9e3', '#7db3d8', '#4a90c4', '#2e6fa8', '#0d4a70'],
  7: ['#d0e5f5', '#9cc9e3', '#7db3d8', '#5da3ce', '#4a90c4', '#2e6fa8', '#0d4a70']
};

/* üåç STUDENTS - DEFINE YOUR CUSTOM INTERVAL BREAKS FOR POPDENS */
// Custom breaks define the upper boundary of each class
// Example: [30, 75, 150, 300, 600] creates these classes:
//   Class 1: < 30
//   Class 2: 30 - 75
//   Class 3: 75 - 150
//   Class 4: 150 - 300
//   Class 5: 300 - 600
//   Class 6: > 600
const customBreaks = [30, 75, 150, 300, 600];  // üåç 5 breaks = 6 classes
const customColors = ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#de2d26'];  // üó∫Ô∏è 6 colors

/* üåç STUDENTS - DEFINE YOUR CUSTOM INTERVAL BREAKS FOR DENS_COVER */
const denscoverCustomBreaks = [500, 1500, 3500, 6000, 8500];  // üåç Example breaks for dasymmetric
const denscoverCustomColors = ['#f0f9ff', '#c6dbef', '#6baed6', '#2171b5', '#08519c', '#08306b'];  // üó∫Ô∏è 6 colors

// ============================================================
// 4. CLASSIFICATION FUNCTIONS
// ============================================================
// These functions calculate class breaks based on the data values
// Three methods are available: Equal Interval, Quantiles, and Natural Breaks (Jenks)

/**
 * Equal Interval Classification
 * Divides the range of values into equal-sized intervals
 * Example: If min=0 and max=100 with 5 classes, breaks at 20, 40, 60, 80
 */
function equalIntervalBreaks(sorted, n) {
  const min = sorted[0];
  const max = sorted[sorted.length-1];
  if (min === max) return [max];
  const step = (max - min) / n;
  const breaks = [];
  for (let i=1; i<n; i++) {
    breaks.push(min + step*i);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

/**
 * Quantile Classification
 * Each class contains approximately the same number of features
 * Good for evenly distributed data display
 */
function quantileBreaks(sorted, n) {
  const breaks = [];
  for (let i=1; i<n; i++){
    const idx = Math.floor((sorted.length * i)/n);
    breaks.push(sorted[Math.min(idx, sorted.length-1)]);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

/**
 * Natural Breaks (Jenks) Classification
 * Minimizes within-class variance and maximizes between-class variance
 * Creates breaks where there are natural "gaps" in the data
 * This is the most complex algorithm but often produces the best-looking maps
 */
function jenksBreaks(sorted, numClasses) {
  const n = sorted.length;
  // Create matrices to store variance calculations
  const mat1 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));
  const mat2 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));

  // Initialize matrices
  for (let i=1; i<=numClasses; i++) {
    mat1[1][i] = 1;
    mat2[1][i] = 0;
    for (let j=2; j<=n; j++) {
      mat2[j][i] = Infinity;
    }
  }

  // Fill matrices using dynamic programming
  for (let l=2; l<=n; l++) {
    let s1=0, s2=0, w=0;
    for (let m=1; m<=l; m++) {
      const i3 = l - m + 1;
      const val = sorted[i3 - 1];
      s2 += val*val;
      s1 += val;
      w++;
      const v = s2 - (s1*s1)/w;
      const i4 = i3 - 1;
      if (i4 !== 0) {
        for (let j=2; j<=numClasses; j++){
          if (mat2[l][j] >= (v + mat2[i4][j-1])) {
            mat1[l][j] = i3;
            mat2[l][j] = v + mat2[i4][j-1];
          }
        }
      }
    }
    mat1[l][1] = 1;
    mat2[l][1] = mat2[l-1][1] + (sorted[l-1]-sorted[0])*(sorted[l-1]-sorted[0]);
  }

  // Extract break points from matrices
  const breaks = [];
  let k = n;
  for (let j = numClasses; j >= 2; j--) {
    const id = mat1[k][j] - 1;
    breaks.push(sorted[id]);
    k = mat1[k][j] - 1;
  }
  return breaks.reverse().map(b => Number(b.toFixed(2)));
}

/**
 * Main function to calculate breaks based on selected method
 * This is called whenever the user changes classification settings
 */
function calculateBreaks(values, numClasses, method, isCustom, customBreaksArray) {
  const sorted = values.filter(v => v != null && !isNaN(v)).sort((a,b)=>a-b);
  if (sorted.length === 0) return [];
  if (method === 'equal') return equalIntervalBreaks(sorted, numClasses);
  if (method === 'quantile') return quantileBreaks(sorted, numClasses);
  if (method === 'natural') return jenksBreaks(sorted, numClasses);
  if (method === 'custom') return customBreaksArray;
  return equalIntervalBreaks(sorted, numClasses);  // Fallback to equal interval
}

/**
 * Creates a MapLibre expression for color styling
 * The 'step' expression assigns colors based on data values and break points
 */
function createStepExpression(breaks, colors, field) {
  const expr = ['step', ['get', field], colors[0]];  // Start with base color
  for (let i=0; i<breaks.length; i++){
    expr.push(breaks[i]);                             // Add break value
    expr.push(colors[i+1] || colors[colors.length-1]); // Add corresponding color
  }
  return expr;
}

/**
 * Ensures a data source exists in the map
 * If it doesn't exist, create it; if it does, update its data
 */
function ensureSource(id, urlOrGeojson) {
  if (!map.getSource(id)) {
    map.addSource(id, { type: 'geojson', data: urlOrGeojson });
  } else {
    if (typeof urlOrGeojson === 'object') {
      map.getSource(id).setData(urlOrGeojson);
    }
  }
}

// ============================================================
// 5. LAYER LOADING FUNCTIONS
// ============================================================
// Each function loads and displays a specific map layer
// The pattern is: fetch data ‚Üí calculate styling ‚Üí add to map

/**
 * CHOROPLETH MAP (POPDENS) - Classification and Display
 * This function is called whenever the choropleth settings change
 * It recalculates breaks and updates the map styling
 */
function applyPopDensClassification() {
  if (!popdensData) {
    console.warn('No popdensData cached.');
    return;
  }
  
  const method = document.getElementById('classificationMethod').value;
  const nclasses = parseInt(document.getElementById('numClasses').value,10);
  
  let colors, breaks;
  
  if (method === 'custom') {
    // Use student-defined custom breaks
    breaks = customBreaks;
    colors = customColors;
  } else {
    // Calculate breaks automatically based on data
    colors = colorSchemes[nclasses] || colorSchemes[5];
    const values = popdensData.features.map(f => parseFloat(f.properties[layerDefinitions.popdens.dataField]));
    breaks = calculateBreaks(values, nclasses, method, false, null);
  }

  // Create the color expression for MapLibre
  const expr = createStepExpression(breaks, colors, layerDefinitions.popdens.dataField);
  ensureSource(layerDefinitions.popdens.sourceId, popdensData);

  // Add layer to map or update existing layer
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.popdens.layerId,
      type: 'fill',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('denscoverOpacity').value,10)/100
      }
    });
  }

  layerDefinitions.denscover.breaks = breaks;
  layerDefinitions.denscover.colors = colors;
  enabledLayers.denscover = true;
  document.getElementById('denscoverControls').style.display = 'block';
  updateLegend();
}

/**
 * DASYMMETRIC MAP (DENS_COVER) - Initial Data Loading
 */
function loadDensCoverLayer() {
  fetch(layerDefinitions.denscover.url)
    .then(r => r.json())
    .then(gj => {
      denscoverData = gj;
      applyDensCoverClassification();
    })
    .catch(err => {
      console.error('Failed to load DENS_COVER:', err);
      alert('Error loading DENS_COVER geojson. Check file path.');
    });
}

/**
 * PROPORTIONAL SYMBOLS (POPMUN) - Display circles sized by population
 * Uses Flannery scaling (power of 0.57) for better visual perception
 */
function loadPoipopLayer() {
  const def = layerDefinitions.poipop;
  ensureSource(def.sourceId, def.url);

  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 100000;
  // Flannery formula: radius = (value/maxValue)^0.57 * maxRadius
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': 'rgba(255,0,0,0.25)',  // üó∫Ô∏è STUDENTS: Change circle fill color
        'circle-radius': radiusExpr,
        'circle-opacity': parseInt(document.getElementById('poipopOpacity').value,10)/100,
        'circle-stroke-color': 'red',  // üó∫Ô∏è STUDENTS: Change circle outline color
        'circle-stroke-width': 0.8
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
    map.setPaintProperty(def.layerId, 'circle-opacity', parseInt(document.getElementById('poipopOpacity').value,10)/100);
  }

  enabledLayers.poipop = true;
  document.getElementById('poipopControls').style.display = 'block';
  updateLegend();
}

/**
 * Update circle radius when slider changes
 */
function updatePoipopRadius() {
  const def = layerDefinitions.poipop;
  if (!map.getLayer(def.layerId)) return;
  
  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 100000;
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];
  
  map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
  updateLegend();
}

/**
 * CONTOURS/ISOPLETHS - Lines representing population potential
 * Uses ID field to differentiate primary (thicker) and secondary (thinner) lines
 */
function loadContoursLayer() {
  const def = layerDefinitions.contours;
  ensureSource(def.sourceId, def.url);

  // Conditional expression: if ID=1 use width 3, otherwise use 1.2
  const widthExpr = ['case', ['==', ['get', 'ID'], 1], 3, 1.2];
  const color = '#8B0000';  // üó∫Ô∏è STUDENTS: Change contour line color

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': color,
        'line-width': widthExpr,
        'line-opacity': parseInt(document.getElementById('contoursOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-width', widthExpr);
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('contoursOpacity').value,10)/100);
  }

  enabledLayers.contours = true;
  document.getElementById('contoursControls').style.display = 'block';
  updateLegend();
}

/**
 * DOT DENSITY MAP - Each dot represents a certain number of people
 */
function loadDotsLayer() {
  const def = layerDefinitions.dots;
  ensureSource(def.sourceId, def.url);

  const dotSize = parseFloat(document.getElementById('dotSize').value);
  const opacity = parseInt(document.getElementById('dotsOpacity').value,10)/100;

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': '#000000',  // üó∫Ô∏è STUDENTS: Change dot color
        'circle-radius': dotSize,
        'circle-opacity': opacity
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', dotSize);
    map.setPaintProperty(def.layerId, 'circle-opacity', opacity);
  }

  enabledLayers.dots = true;
  document.getElementById('dotsControls').style.display = 'block';
  updateLegend();
}

/**
 * MUNICIPAL BOUNDARIES - Simple line layer
 */
function loadBoundariesLayer() {
  const def = layerDefinitions.boundaries;
  ensureSource(def.sourceId, def.url);

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': '#bbbbbb',  // üó∫Ô∏è STUDENTS: Change boundary line color
        'line-width': 1,
        'line-opacity': parseInt(document.getElementById('boundariesOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('boundariesOpacity').value,10)/100);
  }

  enabledLayers.boundaries = true;
  document.getElementById('boundariesControls').style.display = 'block';
  updateLegend();
}

/**
 * Remove a layer from the map
 * Called when user unchecks a layer
 */
function removeLayer(name) {
  const def = layerDefinitions[name];
  if (map.getLayer(def.layerId)) map.removeLayer(def.layerId);
  if (map.getSource(def.sourceId)) map.removeSource(def.sourceId);
  enabledLayers[name] = false;
  const c = document.getElementById(name + 'Controls');
  if (c) c.style.display = 'none';
  updateLegend();
}

// ============================================================
// 6. LEGEND GENERATION
// ============================================================
// Dynamically creates the legend HTML based on active layers

/* üåç STUDENTS - MODIFY LEGEND TITLE AND TEXT */
function updateLegend() {
  const legend = document.getElementById('legend');
  let html = '';

  /* üåç STUDENTS: Change the text below to customize your map title and credits */
  html += `
    <div class="legend-header">
      <div class="legend-map-title">THESSALY POPULATION</div>
      <div class="legend-subtitle">
        (Thematic maps based on 2021 population data)
      </div>
      <div class="legend-author">
        <strong>Data source:</strong> Hellenic Statistical Authority<br>
        <strong>Produced by:</strong> Loukas Katikas<br>
        National Technical University of Athens (NTUA)<br>
        School of Rural, Surveying & Geoinformatics Engineering<br>
        Cartography Laboratory<br>
        Thematic Cartography, Academic Year 2025-2026
      </div>
    </div>
  `;

  // Choropleth legend (if active)
  if (enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    const breaks = layerDefinitions.popdens.breaks;
    const colors = layerDefinitions.popdens.colors;
    
    html += `<div class="legend-title">Choropleth map (people / km¬≤)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  // Dasymmetric legend (if active)
  if (enabledLayers.denscover && layerDefinitions.denscover.breaks) {
    const breaks = layerDefinitions.denscover.breaks;
    const colors = layerDefinitions.denscover.colors;
    
    html += `<div class="legend-title">Dasymmetric map (people / km¬≤ by land cover zone)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  /* üåç STUDENTS - MODIFY LEGEND CIRCLE SIZES */
  // Proportional symbols legend (if active)
  if (enabledLayers.poipop) {
    const maxR = parseInt(document.getElementById('maxRadius').value,10);
    const maxVal = layerDefinitions.poipop.maxValueApprox || 100000;
    
    // üåç STUDENTS: Change these values to match your data ranges
    const vSmall = 1000;     // Small population
    const vMed = 10000;      // Medium population
    const vMedLarge = 50000; // Medium-large population
    const vLarge = 100000;   // Large population
    
    // Calculate circle radii using Flannery scaling
    const r1 = Math.max(2, Math.pow(vSmall / maxVal, 0.57) * maxR);
    const r2 = Math.max(2, Math.pow(vMed / maxVal, 0.57) * maxR);
    const r3 = Math.max(2, Math.pow(vMedLarge / maxVal, 0.57) * maxR);
    const r4 = Math.max(2, Math.pow(vLarge / maxVal, 0.57) * maxR);
    
    const svgHeight = Math.round(Math.max(r4*2 + 20, 140));
    const cx = 110;
    const baseY = svgHeight - 10;

    html += `<div class="legend-title">Population (indicative values)</div>`;
    html += `<div style="text-align:center"><svg width="240" height="${svgHeight}">`;
    
    // Draw circles from bottom to top
    html += `<circle cx="${cx}" cy="${baseY - r1}" r="${r1}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r1*2) - 4}" text-anchor="middle" font-size="11">1,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r2}" r="${r2}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r2*2) - 4}" text-anchor="middle" font-size="11">10,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r3}" r="${r3}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r3*2) - 4}" text-anchor="middle" font-size="11">50,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r4}" r="${r4}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r4*2) - 4}" text-anchor="middle" font-size="11">100,000</text>`;
    // üó∫Ô∏è STUDENTS: Change circle colors by modifying fill="rgba(...)" and stroke="..." above
    
    html += `</svg></div><hr>`;
  }

  // Contours legend (if active)
  if (enabledLayers.contours) {
    html += `<div class="legend-title">Population dynamic (2M & 4M)</div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="3"/></svg><div>Primary (Id = 1)</div></div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="1.2"/></svg><div>Secondary (Id = 2)</div></div>`;
    // üó∫Ô∏è STUDENTS: Change stroke="#8B0000" to modify contour line color in legend
    html += '<hr>';
  }

  // Dot density legend (if active)
  if (enabledLayers.dots) {
    html += `<div class="legend-title">Population density</div>`;
    html += `<div class="legend-row"><svg width="30" height="24"><circle cx="15" cy="12" r="${parseFloat(document.getElementById('dotSize').value)}" fill="#000"/></svg><div>1 dot = 500 people</div></div>`;
    // üó∫Ô∏è STUDENTS: Change fill="#000" for dot color and "500 people" to match your data
    html += '<hr>';
  }

  // Boundaries legend (if active)
  if (enabledLayers.boundaries) {
    html += `<div class="legend-row"><svg width="40" height="18"><line x1="0" y1="9" x2="40" y2="9" stroke="#bbbbbb" stroke-width="1"/></svg> <div>Municipal boundaries</div></div>`;
    // üó∫Ô∏è STUDENTS: Change stroke="#bbbbbb" for boundary line color in legend
  }

  // Display legend if any layer is active
  if (html.length) {
    legend.innerHTML = html;
    legend.style.display = 'block';
  } else {
    legend.style.display = 'none';
  }
}

/**
 * Show/hide layer controls based on checkbox state
 */
function showHideControls() {
  Object.keys(enabledLayers).forEach(k => {
    const checkbox = document.getElementById(k + 'Toggle');
    const controls = document.getElementById(k + 'Controls');
    if (!controls) return;
    controls.style.display = checkbox.checked ? 'block' : 'none';
  });
}

// ============================================================
// 7. EVENT LISTENERS
// ============================================================
// These connect user interface interactions to the functions above
// Whenever a user clicks, drags a slider, or changes a dropdown,
// these listeners "hear" the event and call the appropriate function

// --- CHOROPLETH MAP CONTROLS ---
document.getElementById('popdensToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPopDensLayer(); } else { removeLayer('popdens'); }
});

document.getElementById('classificationMethod').addEventListener('change', () => {
  const method = document.getElementById('classificationMethod').value;
  const numClassesLabel = document.getElementById('numClassesLabel');
  const numClassesSelect = document.getElementById('numClasses');
  
  // Disable number of classes when custom is selected
  if (method === 'custom') {
    numClassesSelect.disabled = true;
    numClassesLabel.style.opacity = '0.5';
  } else {
    numClassesSelect.disabled = false;
    numClassesLabel.style.opacity = '1';
  }
  
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('numClasses').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('popdensOpacity').addEventListener('input', (e) => {
  document.getElementById('popdensOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

// --- DASYMMETRIC MAP CONTROLS ---
document.getElementById('denscoverToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDensCoverLayer(); } else { removeLayer('denscover'); }
});

document.getElementById('denscoverClassificationMethod').addEventListener('change', () => {
  const method = document.getElementById('denscoverClassificationMethod').value;
  const numClassesLabel = document.getElementById('denscoverNumClassesLabel');
  const numClassesSelect = document.getElementById('denscoverNumClasses');
  
  if (method === 'custom') {
    numClassesSelect.disabled = true;
    numClassesLabel.style.opacity = '0.5';
  } else {
    numClassesSelect.disabled = false;
    numClassesLabel.style.opacity = '1';
  }
  
  if (enabledLayers.denscover) applyDensCoverClassification();
});

document.getElementById('denscoverNumClasses').addEventListener('change', () => {
  if (enabledLayers.denscover) applyDensCoverClassification();
});

document.getElementById('denscoverOpacity').addEventListener('input', (e) => {
  document.getElementById('denscoverOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

// --- PROPORTIONAL SYMBOLS CONTROLS ---
document.getElementById('poipopToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPoipopLayer(); } else { removeLayer('poipop'); }
});

document.getElementById('maxRadius').addEventListener('input', (e) => {
  document.getElementById('maxRadiusLabel').textContent = e.target.value;
  updatePoipopRadius();
});

document.getElementById('poipopOpacity').addEventListener('input', (e) => {
  document.getElementById('poipopOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.poipop.layerId)) {
    map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

// --- CONTOURS CONTROLS ---
document.getElementById('contoursToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadContoursLayer(); } else { removeLayer('contours'); }
});

document.getElementById('contoursOpacity').addEventListener('input', (e) => {
  document.getElementById('contoursOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.contours.layerId)) {
    map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

// --- DOT MAP CONTROLS ---
document.getElementById('dotsToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDotsLayer(); } else { removeLayer('dots'); }
});

document.getElementById('dotSize').addEventListener('input', (e) => {
  document.getElementById('dotSizeLabel').textContent = e.target.value;
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
  }
});

document.getElementById('dotsOpacity').addEventListener('input', (e) => {
  document.getElementById('dotsOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

// --- BOUNDARIES CONTROLS ---
document.getElementById('boundariesToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadBoundariesLayer(); } else { removeLayer('boundaries'); }
});

document.getElementById('boundariesOpacity').addEventListener('input', (e) => {
  document.getElementById('boundariesOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.boundaries.layerId)) {
    map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

// --- BASEMAP SWITCHING ---
// When changing basemap, we need to reload all active layers
document.getElementById('basemapSelect').addEventListener('change', (e) => {
  const style = e.target.value;
  const enabledSnapshot = {...enabledLayers};  // Remember which layers were active
  map.setStyle(style);
  
  // Once new style loads, re-add all previously active layers
  map.once('styledata', () => {
    for (const key in enabledSnapshot) {
      if (enabledSnapshot[key]) {
        if (key === 'popdens') {
          if (popdensData) { applyPopDensClassification(); } else { loadPopDensLayer(); }
        } else if (key === 'denscover') {
          if (denscoverData) { applyDensCoverClassification(); } else { loadDensCoverLayer(); }
        } else if (key === 'poipop') { loadPoipopLayer();
        } else if (key === 'contours') { loadContoursLayer();
        } else if (key === 'dots') { loadDotsLayer();
        } else if (key === 'boundaries') { loadBoundariesLayer(); }
      }
    }
  });
});

// Initialize controls visibility
showHideControls();

// Listen for changes to any UI input and update legend
const uiInputs = ['classificationMethod','numClasses','popdensOpacity','denscoverClassificationMethod','denscoverNumClasses','denscoverOpacity','maxRadius','poipopOpacity','contoursOpacity','dotSize','dotsOpacity','boundariesOpacity'];
uiInputs.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('input', () => { updateLegend(); });
});

// Listen for checkbox changes to update controls and legend
['popdensToggle','denscoverToggle','poipopToggle','contoursToggle','dotsToggle','boundariesToggle'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    showHideControls();
    updateLegend();
  });
});

// Map load event (currently empty but available for future use)
map.on('load', () => {
  console.log('Map loaded successfully');
});

// Log initialization info to browser console
console.log('Thessaly Cartography Viewer - Ready');
console.log('Data files expected in "data/" folder');
console.log('Layer definitions:', layerDefinitions);

// ============================================================
// END OF JAVASCRIPT SECTION
// ============================================================

/* 
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë        INSTRUCTIONS FOR STUDENTS                          ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

HOW TO USE THIS FILE:
1. Save this file as "map.html" (or any name ending in .html)
2. Create a "data/" folder in the same location
3. Place all your GeoJSON files in the "data/" folder
4. Open the HTML file in a web browser (Chrome, Firefox, Edge, etc.)

KEY CUSTOMIZATION POINTS:
üåç = Mandatory changes (MUST modify for your project)
üó∫Ô∏è = Optional changes (modify to improve appearance)

WHAT YOU NEED TO MODIFY:

üåç MANDATORY:
- Map center coordinates [longitude, latitude]
- Zoom level
- Data file paths (all 6 GeoJSON files)
- Field names in your GeoJSON files
- Maximum population value for circle scaling
- Custom classification breaks and colors
- Legend text (title, subtitle, author, data source)
- Circle sizes in legend to match your data

üó∫Ô∏è OPTIONAL (for better appearance):
- Color schemes for choropleth and dasymmetric maps
- Circle colors for proportional symbols
- Contour line colors
- Dot colors
- Boundary line colors
- Legend styling (fonts, colors, sizes)

UNDERSTANDING THE CODE FLOW:
1. User clicks a checkbox ‚Üí Event listener activated
2. Event listener calls loading function ‚Üí Data fetched from file
3. Loading function calls classification function ‚Üí Breaks calculated
4. Classification function creates styling ‚Üí Colors assigned to values
5. Styling applied to map ‚Üí Layer becomes visible
6. Legend function called ‚Üí Legend updated with new colors/breaks

TROUBLESHOOTING:
- If map doesn't load: Check file paths in layerDefinitions
- If layer doesn't appear: Open browser console (F12) to see errors
- If colors look wrong: Check color arrays match number of breaks
- If circles too small/large: Adjust maxValueApprox and legend values

For questions, refer to MapLibre GL documentation:
https://maplibre.org/maplibre-gl-js/docs/
*/

</script>
</body>
</html>: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('popdensOpacity').value,10)/100
      }
    });
  }

  // Store breaks and colors for legend generation
  layerDefinitions.popdens.breaks = breaks;
  layerDefinitions.popdens.colors = colors;
  enabledLayers.popdens = true;
  document.getElementById('popdensControls').style.display = 'block';
  updateLegend();
}

/**
 * CHOROPLETH MAP (POPDENS) - Initial Data Loading
 * Fetches the GeoJSON file from the server
 */
function loadPopDensLayer() {
  fetch(layerDefinitions.popdens.url)
    .then(r => r.json())
    .then(gj => {
      popdensData = gj;
      applyPopDensClassification();
    })
    .catch(err => {
      console.error('Failed to load POPDENS:', err);
      alert('Error loading POPDENS geojson. Check file path.');
    });
}

/**
 * DASYMMETRIC MAP (DENS_COVER) - Classification and Display
 * Same logic as choropleth but for the dasymmetric layer
 */
function applyDensCoverClassification() {
  if (!denscoverData) {
    console.warn('No denscoverData cached.');
    return;
  }
  
  const method = document.getElementById('denscoverClassificationMethod').value;
  const nclasses = parseInt(document.getElementById('denscoverNumClasses').value,10);
  
  let colors, breaks;
  
  if (method === 'custom') {
    breaks = denscoverCustomBreaks;
    colors = denscoverCustomColors;
  } else {
    colors = denscoverColorSchemes[nclasses] || denscoverColorSchemes[5];
    const values = denscoverData.features.map(f => parseFloat(f.properties[layerDefinitions.denscover.dataField]));
    breaks = calculateBreaks(values, nclasses, method, false, null);
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.denscover.dataField);
  ensureSource(layerDefinitions.denscover.sourceId, denscoverData);

  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.denscover.layerId,
      type: 'fill',
      source: layerDefinitions.denscover.sourceId,
      paint
