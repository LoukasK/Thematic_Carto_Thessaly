<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessaly Cartography ‚Äì Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />

<!-- ============================================================
     EXTERNAL LIBRARIES - MAPLIBRE GL
     ============================================================
     MapLibre GL is an open-source library for displaying interactive maps
     We need both the CSS (for styling) and JavaScript (for functionality)
     ============================================================ -->

<!--
MapLibre GL CSS
- Provides the visual styling for the map
- Styles map controls (zoom buttons, attribution, scale bar)
- Ensures correct layout and appearance of the map canvas
-->
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />

<!--
MapLibre GL JavaScript
- Core MapLibre library for web mapping
- Handles map rendering using WebGL
- Enables interaction (zoom, pan, rotation)
- Supports loading layers, GeoJSON data, and user events
-->
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<!-- ============================================================
     CSS STYLING SECTION
     ============================================================
     This <style> section contains all the visual styling rules for:
     - Map container layout
     - Control panels (left side)
     - Legend (top right) 
     - Buttons, sliders, and other UI elements
     
     Students: You generally don't need to modify CSS unless you want
     to change the appearance of the interface itself
     ============================================================ -->
<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }

  #styleSelector {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 6px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.25);
  }

  #controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 10px;
    font-size: 13px;
    border-radius: 6px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  }
  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 6;
    background: white;
    padding: 18px;
    font-size: 13px;
    border-radius: 6px;
    max-width: 360px;
    max-height: 85vh;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    display: none;
    resize: both;
    overflow: auto;
    min-width: 200px;
    min-height: 100px;
  }
  
  /* üåç STUDENTS - MODIFY HEADER STYLES: Change title/subtitle/author font sizes and colors here */
  .legend-header {
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #333;
  }
  .legend-map-title {
    font-size: 15px; /* üåç STUDENTS: Adjust size for main title */
    font-weight: 700;
    color: #000; /* üåç STUDENTS: Change hex code for different title color */
    margin-bottom: 10px;
    line-height: 1.4;
    text-align: center;
  }
  .legend-subtitle {
    font-size: 11px; /* üåç STUDENTS: Adjust size for subtitle */
    font-style: italic;
    color: #333; /* üåç STUDENTS: Change subtitle color */
    margin-bottom: 10px;
    line-height: 1.3;
    text-align: center;
  }
  .legend-author {
    font-size: 10px; /* üåç STUDENTS: Adjust size for author information */
    color: #555; /* üåç STUDENTS: Change author text color */
    line-height: 1.4;
    text-align: left;
  }
  .legend-author strong {
    font-weight: 700;
  }
  
  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
<!-- ============================================================
     END OF CSS STYLING SECTION
     ============================================================ -->
</head>
<body>

<!-- ============================================================
     HTML STRUCTURE SECTION - USER INTERFACE ELEMENTS
     ============================================================
     This section defines the visual interface that users interact with:
     - Basemap selector (Light/Dark)
     - Layer checkboxes and controls (left panel)
     - Legend (right panel, dynamically updated by JavaScript)
     - Map container (fills the entire background)
     ============================================================ -->

<!-- Basemap selector dropdown (Light or Dark background map) -->
<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>
</div>

<!-- Layer controls panel (left side of screen) -->
<div id="controls">
  <strong>Layers</strong><br><br>

  <!-- Layer 1: Population Density Choropleth Map -->
  <input type="checkbox" id="popdensToggle"> <strong>Population Density (Choropleth Map)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Classification method:
      <select id="classificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">Custom intervals</option>
      </select>
    </label>
    <label id="numClassesLabel">Number of classes:
      <select id="numClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="popdensOpacityLabel" class="control-value">60%</span>
      <input type="range" id="popdensOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <!-- Layer 2: Population Density Dasymmetric Map -->
  <input type="checkbox" id="denscoverToggle"> <strong>Population Density (Dasymmetric Map)</strong><br>
  <div class="layer-controls" id="denscoverControls">
    <label>Classification method:
      <select id="denscoverClassificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
        <option value="custom">Custom intervals</option>
      </select>
    </label>
    <label id="denscoverNumClassesLabel">Number of classes:
      <select id="denscoverNumClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="denscoverOpacityLabel" class="control-value">60%</span>
      <input type="range" id="denscoverOpacity" min="0" max="100" value="60">
    </label>
  </div>
  <hr>

  <!-- Layer 3: Population Proportional Symbols -->
  <input type="checkbox" id="poipopToggle"> <strong>Population (Proportional symbols)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Maximum circle radius (px): <span id="maxRadiusLabel" class="control-value">70</span>
      <input type="range" id="maxRadius" min="20" max="200" value="70">
    </label>
    <label>Opacity (circles): <span id="poipopOpacityLabel" class="control-value">25%</span>
      <input type="range" id="poipopOpacity" min="0" max="100" value="25">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      <strong>Note (students):</strong> Flannery scaling is used for perceptual equality.
    </small>
  </div>
  <hr>

  <!-- Layer 4: Population Dynamic Contours (Isopleths) -->
  <input type="checkbox" id="contoursToggle"> <strong>Population dynamic (Isopleths map)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity (contours): <span id="contoursOpacityLabel" class="control-value">80%</span>
      <input type="range" id="contoursOpacity" min="0" max="100" value="80">
    </label>
  </div>
  <hr>

  <!-- Layer 5: Population Dot Map -->
  <input type="checkbox" id="dotsToggle"> <strong>Population (Dot map)</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Dot size (px): <span id="dotSizeLabel" class="control-value">1.9</span>
      <input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="1.9">
    </label>
    <label>Opacity (dots): <span id="dotsOpacityLabel" class="control-value">100%</span>
      <input type="range" id="dotsOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Layer 6: Municipal Boundaries -->
  <input type="checkbox" id="boundariesToggle"> <strong>Municipal boundaries</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity (boundaries): <span id="boundariesOpacityLabel" class="control-value">100%</span>
      <input type="range" id="boundariesOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <!-- Data notes for students -->
  <div style="font-size:12px;color:#555">
    <strong>Data notes (students)</strong><br>
    - All GeoJSONs expected in <code>data/</code> folder<br>
    - Fields: <code>POPDENS</code>, <code>DENS_COVER</code>, <code>POPMUN</code>, <code>ID</code>
  </div>
</div>

<!-- Legend container (right side, dynamically populated by JavaScript) -->
<div id="legend"></div>

<!-- Map container (fills entire background) -->
<div id="map"></div>

<!-- ============================================================
     END OF HTML STRUCTURE SECTION
     ============================================================ -->

<!-- ============================================================
     JAVASCRIPT SECTION - APPLICATION LOGIC
     ============================================================
     This is where all the interactive functionality is defined.
     The code is organized in the following flow:
     
     1. MAP INITIALIZATION - Create the map object
     2. DATA CONFIGURATION - Define where data files are located
     3. COLOR SCHEMES - Define colors for visualizations
     4. CLASSIFICATION FUNCTIONS - Calculate class breaks
     5. LAYER LOADING FUNCTIONS - Load and display each layer
     6. LEGEND FUNCTION - Generate legend dynamically
     7. EVENT LISTENERS - Respond to user interactions
     
     Students: Focus on sections marked with üåç (mandatory changes)
     and üó∫Ô∏è (optional styling changes)
     ============================================================ -->
<script>

// ============================================================
// 1. MAP INITIALIZATION
// ============================================================
// This creates the interactive map object that will display everything

/* üåç STUDENTS - MODIFY MAP CENTER AND ZOOM */
const map = new maplibregl.Map({
  container: 'map',           // Links to the <div id="map"> element in HTML
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',  // Initial basemap style
  center: [22.4, 39.6],       // üåç STUDENTS: [longitude, latitude] for your study area
  zoom: 8                     // üåç STUDENTS: Zoom level (0=world, 20=street level)
});

// ============================================================
// 2. DATA CONFIGURATION
// ============================================================
// This object defines where each GeoJSON file is located and which
// field contains the data to visualize

/* üåç STUDENTS - MODIFY DATA FILE PATHS AND FIELD NAMES */
const layerDefinitions = {
  // Choropleth map layer (population density by municipality)
  popdens: {
    sourceId: 'popdens-src',                       // Internal ID for the data source
    layerId: 'popdens-layer',                      // Internal ID for the map layer
    url: 'data/dimoi_popdens_WGS.geojson',        // üåç STUDENTS: Path to your file
    dataField: 'POPDENS'                           // üåç STUDENTS: Column name in your GeoJSON
  },
  // Dasymmetric map layer (population density by land cover zone)
  denscover: {
    sourceId: 'denscover-src',
    layerId: 'denscover-layer',
    url: 'data/dimoi_popdens_cover_WGS.geojson',  // üåç STUDENTS: Path to your file
    dataField: 'DENS_COVER'                        // üåç STUDENTS: Column name in your GeoJSON
  },
  // Proportional symbols layer (circles sized by population)
  poipop: {
    sourceId: 'poipop-src',
    layerId: 'poipop-layer',
    url: 'data/dimoi_poi_pop_WGS.geojson',        // üåç STUDENTS: Path to your file
    dataField: 'POPMUN',                           // üåç STUDENTS: Column name in your GeoJSON
    maxValueApprox: 100000                         // üåç STUDENTS: Approximate maximum value (for scaling circles)
  },
  // Contours/isopleths layer (population potential lines)
  contours: {
    sourceId: 'contours-src',
    layerId: 'contours-layer',
    url: 'data/pop_contours_200k_WGS.geojson'     // üåç STUDENTS: Path to your file
  },
  // Dot density layer (each dot represents X people)
  dots: {
    sourceId: 'dots-src',
    layerId: 'dots-layer',
    url: 'data/pop_dots_300_WGS.geojson'          // üåç STUDENTS: Path to your file
  },
  // Boundaries layer (municipal borders)
  boundaries: {
    sourceId: 'boundaries-src',
    layerId: 'boundaries-layer',
    url: 'data/dimoi_oria_WGS.geojson'            // üåç STUDENTS: Path to your file
  }
};

// Variables to cache loaded data (so we don't reload it every time)
let popdensData = null;      // Stores choropleth data once loaded
let denscoverData = null;    // Stores dasymmetric data once loaded

// Tracks which layers are currently visible on the map
const enabledLayers = { 
  popdens: false,
  denscover: false,
  poipop: false,
  contours: false,
  dots: false,
  boundaries: false
};

// ============================================================
// 3. COLOR SCHEMES
// ============================================================
// These arrays define the colors used for each classification method
// The number of colors must match the number of classes + 1

/* üåç STUDENTS - MODIFY CHOROPLETH COLOR SCHEMES (for POPDENS layer) */
// üó∫Ô∏è Change these hex colors to customize your choropleth appearance
const colorSchemes = {
  3: ['#ffcccc', '#ff6666', '#990000'],           // 3 classes = 4 colors (lightest to darkest)
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'],
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'],  // Default
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
};

/* üåç STUDENTS - MODIFY DASYMMETRIC MAP COLOR SCHEMES (for DENS_COVER layer) */
// üó∫Ô∏è Change these hex colors (blue scheme used here to differentiate from choropleth)
const denscoverColorSchemes = {
  3: ['#d0e5f5', '#4a90c4', '#0d4a70'],
  4: ['#d0e5f5', '#7db3d8', '#2e6fa8', '#0d4a70'],
  5: ['#d0e5f5', '#9cc9e3', '#4a90c4', '#2e6fa8', '#0d4a70'],  // Default
  6: ['#d0e5f5', '#9cc9e3', '#7db3d8', '#4a90c4', '#2e6fa8', '#0d4a70'],
  7: ['#d0e5f5', '#9cc9e3', '#7db3d8', '#5da3ce', '#4a90c4', '#2e6fa8', '#0d4a70']
};

/* üåç STUDENTS - DEFINE YOUR CUSTOM INTERVAL BREAKS FOR POPDENS */
const customBreaks = [30, 75, 150, 300, 600];
const customColors = ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#de2d26'];

/* üåç STUDENTS - DEFINE YOUR CUSTOM INTERVAL BREAKS FOR DENS_COVER */
const denscoverCustomBreaks = [500, 1500, 3500, 6000, 8500];
const denscoverCustomColors = ['#f0f9ff', '#c6dbef', '#6baed6', '#2171b5', '#08519c', '#08306b'];

// ============================================================
// 4. CLASSIFICATION FUNCTIONS
// ============================================================

function equalIntervalBreaks(sorted, n) {
  const min = sorted[0];
  const max = sorted[sorted.length-1];
  if (min === max) return [max];
  const step = (max - min) / n;
  const breaks = [];
  for (let i=1; i<n; i++) {
    breaks.push(min + step*i);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

function quantileBreaks(sorted, n) {
  const breaks = [];
  for (let i=1; i<n; i++){
    const idx = Math.floor((sorted.length * i)/n);
    breaks.push(sorted[Math.min(idx, sorted.length-1)]);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

function jenksBreaks(sorted, numClasses) {
  const n = sorted.length;
  const mat1 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));
  const mat2 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));

  for (let i=1; i<=numClasses; i++) {
    mat1[1][i] = 1;
    mat2[1][i] = 0;
    for (let j=2; j<=n; j++) {
      mat2[j][i] = Infinity;
    }
  }

  for (let l=2; l<=n; l++) {
    let s1=0, s2=0, w=0;
    for (let m=1; m<=l; m++) {
      const i3 = l - m + 1;
      const val = sorted[i3 - 1];
      s2 += val*val;
      s1 += val;
      w++;
      const v = s2 - (s1*s1)/w;
      const i4 = i3 - 1;
      if (i4 !== 0) {
        for (let j=2; j<=numClasses; j++){
          if (mat2[l][j] >= (v + mat2[i4][j-1])) {
            mat1[l][j] = i3;
            mat2[l][j] = v + mat2[i4][j-1];
          }
        }
      }
    }
    mat1[l][1] = 1;
    mat2[l][1] = mat2[l-1][1] + (sorted[l-1]-sorted[0])*(sorted[l-1]-sorted[0]);
  }

  const breaks = [];
  let k = n;
  for (let j = numClasses; j >= 2; j--) {
    const id = mat1[k][j] - 1;
    breaks.push(sorted[id]);
    k = mat1[k][j] - 1;
  }
  return breaks.reverse().map(b => Number(b.toFixed(2)));
}

function calculateBreaks(values, numClasses, method, isCustom, customBreaksArray) {
  const sorted = values.filter(v => v != null && !isNaN(v)).sort((a,b)=>a-b);
  if (sorted.length === 0) return [];
  if (method === 'equal') return equalIntervalBreaks(sorted, numClasses);
  if (method === 'quantile') return quantileBreaks(sorted, numClasses);
  if (method === 'natural') return jenksBreaks(sorted, numClasses);
  if (method === 'custom') return customBreaksArray;
  return equalIntervalBreaks(sorted, numClasses);
}

function createStepExpression(breaks, colors, field) {
  const expr = ['step', ['get', field], colors[0]];
  for (let i=0; i<breaks.length; i++){
    expr.push(breaks[i]);
    expr.push(colors[i+1] || colors[colors.length-1]);
  }
  return expr;
}

function ensureSource(id, urlOrGeojson) {
  if (!map.getSource(id)) {
    map.addSource(id, { type: 'geojson', data: urlOrGeojson });
  } else {
    if (typeof urlOrGeojson === 'object') {
      map.getSource(id).setData(urlOrGeojson);
    }
  }
}

// ============================================================
// 5. LAYER LOADING FUNCTIONS
// ============================================================

function applyPopDensClassification() {
  if (!popdensData) {
    console.warn('No popdensData cached.');
    return;
  }
  
  const method = document.getElementById('classificationMethod').value;
  const nclasses = parseInt(document.getElementById('numClasses').value,10);
  
  let colors, breaks;
  
  if (method === 'custom') {
    breaks = customBreaks;
    colors = customColors;
  } else {
    colors = colorSchemes[nclasses] || colorSchemes[5];
    const values = popdensData.features.map(f => parseFloat(f.properties[layerDefinitions.popdens.dataField]));
    breaks = calculateBreaks(values, nclasses, method, false, null);
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.popdens.dataField);
  ensureSource(layerDefinitions.popdens.sourceId, popdensData);

  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.popdens.layerId,
      type: 'fill',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('popdensOpacity').value,10)/100
      }
    });
  }

  layerDefinitions.popdens.breaks = breaks;
  layerDefinitions.popdens.colors = colors;
  enabledLayers.popdens = true;
  document.getElementById('popdensControls').style.display = 'block';
  updateLegend();
}

function loadPopDensLayer() {
  fetch(layerDefinitions.popdens.url)
    .then(r => r.json())
    .then(gj => {
      popdensData = gj;
      applyPopDensClassification();
    })
    .catch(err => {
      console.error('Failed to load POPDENS:', err);
      alert('Error loading POPDENS geojson.');
    });
}

function applyDensCoverClassification() {
  if (!denscoverData) {
    console.warn('No denscoverData cached.');
    return;
  }
  
  const method = document.getElementById('denscoverClassificationMethod').value;
  const nclasses = parseInt(document.getElementById('denscoverNumClasses').value,10);
  
  let colors, breaks;
  
  if (method === 'custom') {
    breaks = denscoverCustomBreaks;
    colors = denscoverCustomColors;
  } else {
    colors = denscoverColorSchemes[nclasses] || denscoverColorSchemes[5];
    const values = denscoverData.features.map(f => parseFloat(f.properties[layerDefinitions.denscover.dataField]));
    breaks = calculateBreaks(values, nclasses, method, false, null);
  }

  const expr = createStepExpression(breaks, colors, layerDefinitions.denscover.dataField);
  ensureSource(layerDefinitions.denscover.sourceId, denscoverData);

  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.denscover.layerId,
      type: 'fill',
      source: layerDefinitions.denscover.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('denscoverOpacity').value,10)/100
      }
    });
  }

  layerDefinitions.denscover.breaks = breaks;
  layerDefinitions.denscover.colors = colors;
  enabledLayers.denscover = true;
  document.getElementById('denscoverControls').style.display = 'block';
  updateLegend();
}

function loadDensCoverLayer() {
  fetch(layerDefinitions.denscover.url)
    .then(r => r.json())
    .then(gj => {
      denscoverData = gj;
      applyDensCoverClassification();
    })
    .catch(err => {
      console.error('Failed to load DENS_COVER:', err);
      alert('Error loading DENS_COVER geojson.');
    });
}

function loadPoipopLayer() {
  const def = layerDefinitions.poipop;
  ensureSource(def.sourceId, def.url);

  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 100000;
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': 'rgba(255,0,0,0.25)',
        'circle-radius': radiusExpr,
        'circle-opacity': parseInt(document.getElementById('poipopOpacity').value,10)/100,
        'circle-stroke-color': 'red',
        'circle-stroke-width': 0.8
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
    map.setPaintProperty(def.layerId, 'circle-opacity', parseInt(document.getElementById('poipopOpacity').value,10)/100);
  }

  enabledLayers.poipop = true;
  document.getElementById('poipopControls').style.display = 'block';
  updateLegend();
}

function updatePoipopRadius() {
  const def = layerDefinitions.poipop;
  if (!map.getLayer(def.layerId)) return;
  
  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 100000;
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];
  
  map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
  updateLegend();
}

function loadContoursLayer() {
  const def = layerDefinitions.contours;
  ensureSource(def.sourceId, def.url);

  const widthExpr = ['case', ['==', ['get', 'ID'], 1], 3, 1.2];
  const color = '#8B0000';  // üó∫Ô∏è STUDENTS: Change contour line color

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': color,
        'line-width': widthExpr,
        'line-opacity': parseInt(document.getElementById('contoursOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-width', widthExpr);
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('contoursOpacity').value,10)/100);
  }

  enabledLayers.contours = true;
  document.getElementById('contoursControls').style.display = 'block';
  updateLegend();
}

function loadDotsLayer() {
  const def = layerDefinitions.dots;
  ensureSource(def.sourceId, def.url);

  const dotSize = parseFloat(document.getElementById('dotSize').value);
  const opacity = parseInt(document.getElementById('dotsOpacity').value,10)/100;

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': '#000000',  // üó∫Ô∏è STUDENTS: Change dot color
        'circle-radius': dotSize,
        'circle-opacity': opacity
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', dotSize);
    map.setPaintProperty(def.layerId, 'circle-opacity', opacity);
  }

  enabledLayers.dots = true;
  document.getElementById('dotsControls').style.display = 'block';
  updateLegend();
}

function loadBoundariesLayer() {
  const def = layerDefinitions.boundaries;
  ensureSource(def.sourceId, def.url);

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': '#bbbbbb',  // üó∫Ô∏è STUDENTS: Change boundary line color
        'line-width': 1,
        'line-opacity': parseInt(document.getElementById('boundariesOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('boundariesOpacity').value,10)/100);
  }

  enabledLayers.boundaries = true;
  document.getElementById('boundariesControls').style.display = 'block';
  updateLegend();
}

function removeLayer(name) {
  const def = layerDefinitions[name];
  if (map.getLayer(def.layerId)) map.removeLayer(def.layerId);
  if (map.getSource(def.sourceId)) map.removeSource(def.sourceId);
  enabledLayers[name] = false;
  const c = document.getElementById(name + 'Controls');
  if (c) c.style.display = 'none';
  updateLegend();
}

/* üåç STUDENTS - MODIFY LEGEND TITLE AND TEXT */
function updateLegend() {
  const legend = document.getElementById('legend');
  let html = '';

  /* üåç STUDENTS: Change the text below or add new text to customize your map title and credits */
  html += `
    <div class="legend-header">
      <div class="legend-map-title">THESSALY POPULATION</div>
      <div class="legend-author">
        <strong>Data source:</strong> Hellenic Statistical Authority - Population data 2021<br>
        <strong>Produced by:</strong> Loukas Katikas<br>
        <strong>Student ID:</strong> XXX<br>
        National Technical University of Athens (NTUA)<br>
        School of Rural, Surveying & Geoinformatics Engineering<br>
        Cartography Laboratory<br>
        Thematic Cartography, Academic Year 2025-2026
      </div>
    </div>
  `;

  if (enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    const breaks = layerDefinitions.popdens.breaks;
    const colors = layerDefinitions.popdens.colors;
    
    html += `<div class="legend-title">Choropleth map (people / km¬≤)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  if (enabledLayers.denscover && layerDefinitions.denscover.breaks) {
    const breaks = layerDefinitions.denscover.breaks;
    const colors = layerDefinitions.denscover.colors;
    
    html += `<div class="legend-title">Dasymmetric map (people / km¬≤ by land cover zone)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  /* üåç STUDENTS - MODIFY LEGEND CIRCLE SIZES */
  if (enabledLayers.poipop) {
    const maxR = parseInt(document.getElementById('maxRadius').value,10);
    const maxVal = layerDefinitions.poipop.maxValueApprox || 100000;
    
    // üåç STUDENTS: Change these values to match your data ranges
    const vSmall = 1000;
    const vMed = 10000;
    const vMedLarge = 50000;
    const vLarge = 100000;
    
    const r1 = Math.max(2, Math.pow(vSmall / maxVal, 0.57) * maxR);
    const r2 = Math.max(2, Math.pow(vMed / maxVal, 0.57) * maxR);
    const r3 = Math.max(2, Math.pow(vMedLarge / maxVal, 0.57) * maxR);
    const r4 = Math.max(2, Math.pow(vLarge / maxVal, 0.57) * maxR);
    
    const svgHeight = Math.round(Math.max(r4*2 + 20, 140));
    const cx = 110;
    const baseY = svgHeight - 10;

    html += `<div class="legend-title">Population (indicative values)</div>`;
    html += `<div style="text-align:center"><svg width="240" height="${svgHeight}">`;
    
    html += `<circle cx="${cx}" cy="${baseY - r1}" r="${r1}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r1*2) - 4}" text-anchor="middle" font-size="11">1,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r2}" r="${r2}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r2*2) - 4}" text-anchor="middle" font-size="11">10,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r3}" r="${r3}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r3*2) - 4}" text-anchor="middle" font-size="11">50,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r4}" r="${r4}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r4*2) - 4}" text-anchor="middle" font-size="11">100,000</text>`;
    // üó∫Ô∏è STUDENTS: Change circle colors by modifying fill="rgba(...)" and stroke="..." above
    
    html += `</svg></div><hr>`;
  }

  if (enabledLayers.contours) {
    html += `<div class="legend-title">Population dynamic (2M & 4M)</div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="3"/></svg><div>Primary (Id = 1)</div></div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="1.2"/></svg><div>Secondary (Id = 2)</div></div>`;
    // üó∫Ô∏è STUDENTS: Change stroke="#8B0000" to modify contour line color in legend
    html += '<hr>';
  }

  if (enabledLayers.dots) {
    html += `<div class="legend-title">Population density</div>`;
    html += `<div class="legend-row"><svg width="30" height="24"><circle cx="15" cy="12" r="${parseFloat(document.getElementById('dotSize').value)}" fill="#000"/></svg><div>1 dot = 500 people</div></div>`;
    // üó∫Ô∏è STUDENTS: Change fill="#000" for dot color and "500 people" to match your data
    html += '<hr>';
  }

  if (enabledLayers.boundaries) {
    html += `<div class="legend-row"><svg width="40" height="18"><line x1="0" y1="9" x2="40" y2="9" stroke="#bbbbbb" stroke-width="1"/></svg> <div>Municipal boundaries</div></div>`;
    // üó∫Ô∏è STUDENTS: Change stroke="#bbbbbb" for boundary line color in legend
  }

  if (html.length) {
    legend.innerHTML = html;
    legend.style.display = 'block';
  } else {
    legend.style.display = 'none';
  }
}

function showHideControls() {
  Object.keys(enabledLayers).forEach(k => {
    const checkbox = document.getElementById(k + 'Toggle');
    const controls = document.getElementById(k + 'Controls');
    if (!controls) return;
    controls.style.display = checkbox.checked ? 'block' : 'none';
  });
}

document.getElementById('popdensToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPopDensLayer(); } else { removeLayer('popdens'); }
});

document.getElementById('classificationMethod').addEventListener('change', () => {
  const method = document.getElementById('classificationMethod').value;
  const numClassesLabel = document.getElementById('numClassesLabel');
  const numClassesSelect = document.getElementById('numClasses');
  
  if (method === 'custom') {
    numClassesSelect.disabled = true;
    numClassesLabel.style.opacity = '0.5';
  } else {
    numClassesSelect.disabled = false;
    numClassesLabel.style.opacity = '1';
  }
  
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('numClasses').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('popdensOpacity').addEventListener('input', (e) => {
  document.getElementById('popdensOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('denscoverToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDensCoverLayer(); } else { removeLayer('denscover'); }
});

document.getElementById('denscoverClassificationMethod').addEventListener('change', () => {
  const method = document.getElementById('denscoverClassificationMethod').value;
  const numClassesLabel = document.getElementById('denscoverNumClassesLabel');
  const numClassesSelect = document.getElementById('denscoverNumClasses');
  
  if (method === 'custom') {
    numClassesSelect.disabled = true;
    numClassesLabel.style.opacity = '0.5';
  } else {
    numClassesSelect.disabled = false;
    numClassesLabel.style.opacity = '1';
  }
  
  if (enabledLayers.denscover) applyDensCoverClassification();
});

document.getElementById('denscoverNumClasses').addEventListener('change', () => {
  if (enabledLayers.denscover) applyDensCoverClassification();
});

document.getElementById('denscoverOpacity').addEventListener('input', (e) => {
  document.getElementById('denscoverOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.denscover.layerId)) {
    map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('poipopToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPoipopLayer(); } else { removeLayer('poipop'); }
});

document.getElementById('maxRadius').addEventListener('input', (e) => {
  document.getElementById('maxRadiusLabel').textContent = e.target.value;
  updatePoipopRadius();
});

document.getElementById('poipopOpacity').addEventListener('input', (e) => {
  document.getElementById('poipopOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.poipop.layerId)) {
    map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('contoursToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadContoursLayer(); } else { removeLayer('contours'); }
});

document.getElementById('contoursOpacity').addEventListener('input', (e) => {
  document.getElementById('contoursOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.contours.layerId)) {
    map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('dotsToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDotsLayer(); } else { removeLayer('dots'); }
});

document.getElementById('dotSize').addEventListener('input', (e) => {
  document.getElementById('dotSizeLabel').textContent = e.target.value;
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
  }
});

document.getElementById('dotsOpacity').addEventListener('input', (e) => {
  document.getElementById('dotsOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('boundariesToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadBoundariesLayer(); } else { removeLayer('boundaries'); }
});

document.getElementById('boundariesOpacity').addEventListener('input', (e) => {
  document.getElementById('boundariesOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.boundaries.layerId)) {
    map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('basemapSelect').addEventListener('change', (e) => {
  const style = e.target.value;
  const enabledSnapshot = {...enabledLayers};
  map.setStyle(style);
  
  map.once('styledata', () => {
    for (const key in enabledSnapshot) {
      if (enabledSnapshot[key]) {
        if (key === 'popdens') {
          if (popdensData) { applyPopDensClassification(); } else { loadPopDensLayer(); }
        } else if (key === 'denscover') {
          if (denscoverData) { applyDensCoverClassification(); } else { loadDensCoverLayer(); }
        } else if (key === 'poipop') { loadPoipopLayer();
        } else if (key === 'contours') { loadContoursLayer();
        } else if (key === 'dots') { loadDotsLayer();
        } else if (key === 'boundaries') { loadBoundariesLayer(); }
      }
    }
  });
});

showHideControls();

const uiInputs = ['classificationMethod','numClasses','popdensOpacity','denscoverClassificationMethod','denscoverNumClasses','denscoverOpacity','maxRadius','poipopOpacity','contoursOpacity','dotSize','dotsOpacity','boundariesOpacity'];
uiInputs.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('input', () => { updateLegend(); });
});

['popdensToggle','denscoverToggle','poipopToggle','contoursToggle','dotsToggle','boundariesToggle'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    showHideControls();
    updateLegend();
  });
});

map.on('load', () => {});

console.log('Thessaly Cartography Viewer - Ready');
console.log('Data files expected in "data/" folder');
console.log(layerDefinitions);

</script>
</body>
</html>



