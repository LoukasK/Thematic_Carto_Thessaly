<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessaly Cartography ‚Äì Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<!--
MapLibre GL CSS
- Provides the visual styling for the map
- Styles map controls (zoom buttons, attribution, scale bar)
- Ensures correct layout and appearance of the map canvas
-->
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />

<!--
MapLibre GL JavaScript
- Core MapLibre library for web mapping
- Handles map rendering using WebGL
- Enables interaction (zoom, pan, rotation)
- Supports loading layers, GeoJSON data, and user events
-->
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<!-- ============================================================
     CSS STYLING SECTION
     ============================================================
     This <style> section contains all the visual styling rules for:
     - Map container layout
     - Control panels (left side)
     - Legend (top right) 
     - Buttons, sliders, and other UI elements
     ============================================================ -->
<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }

  #styleSelector {
    position: absolute;
    top: 10px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 6px;
    border-radius: 4px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.25);
  }

  #controls {
    position: absolute;
    top: 60px;
    left: 10px;
    z-index: 6;
    background: white;
    padding: 10px;
    font-size: 13px;
    border-radius: 6px;
    width: 300px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
  }
  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }

  #legend {
    position: absolute;
    top: 10px;
    right: 10px;
    z-index: 6;
    background: white;
    padding: 18px;
    font-size: 13px;
    border-radius: 6px;
    max-width: 360px;
    max-height: 85vh;
    box-shadow: 0 2px 6px rgba(0,0,0,0.25);
    display: none;
    resize: both;
    overflow: auto;
    min-width: 200px;
    min-height: 100px;
  }
  
  /* üìù STUDENTS - MODIFY HEADER STYLES: Change title/subtitle/author font sizes and colors here */
  .legend-header {
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 2px solid #333;
  }
  .legend-map-title {
    font-size: 15px; /* üìù STUDENTS: Adjust size for main title */
    font-weight: 700;
    color: #000; /* üìù STUDENTS: Change hex code for different title color */
    margin-bottom: 10px;
    line-height: 1.4;
    text-align: center;
  }
  .legend-subtitle {
    font-size: 11px; /* üìù STUDENTS: Adjust size for subtitle */
    font-style: italic;
    color: #333; /* üìù STUDENTS: Change subtitle color */
    margin-bottom: 10px;
    line-height: 1.3;
    text-align: center;
  }
  .legend-author {
    font-size: 10px; /* üìù STUDENTS: Adjust size for author information */
    color: #555; /* üìù STUDENTS: Change author text color */
    line-height: 1.4;
    text-align: left;
  }
  .legend-author strong {
    font-weight: 700;
  }
  
  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
<!-- ============================================================
     END OF CSS STYLING SECTION
     ============================================================ -->
</head>
<body>

<!-- ============================================================
     HTML STRUCTURE SECTION - USER INTERFACE ELEMENTS
     ============================================================ -->
<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>
</div>

<div id="controls">
  <strong>Layers</strong><br><br>

  <input type="checkbox" id="popdensToggle"> <strong>Population Density (POPDENS)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Classification method:
      <select id="classificationMethod">
        <option value="equal" selected>Equal interval (default)</option>
        <option value="quantile">Quantiles</option>
        <option value="natural">Natural breaks (Jenks)</option>
      </select>
    </label>
    <label>Number of classes:
      <select id="numClasses">
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5" selected>5</option>
        <option value="6">6</option>
        <option value="7">7</option>
      </select>
    </label>
    <label>Opacity: <span id="popdensOpacityLabel" class="control-value">60%</span>
      <input type="range" id="popdensOpacity" min="0" max="100" value="60">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      <strong>Note (students):</strong> change classification method & number of classes to see how choropleth interpretation changes.
    </small>
  </div>
  <hr>

  <input type="checkbox" id="poipopToggle"> <strong>Municipal Population (POPMUN)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Maximum circle radius (px): <span id="maxRadiusLabel" class="control-value">70</span>
      <input type="range" id="maxRadius" min="20" max="200" value="70">
    </label>
    <label>Opacity (circles): <span id="poipopOpacityLabel" class="control-value">25%</span>
      <input type="range" id="poipopOpacity" min="0" max="100" value="25">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      <strong>Note (students):</strong> Flannery scaling is used for perceptual equality.
    </small>
  </div>
  <hr>

  <input type="checkbox" id="contoursToggle"> <strong>Population contours (2M / 4M)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity (contours): <span id="contoursOpacityLabel" class="control-value">80%</span>
      <input type="range" id="contoursOpacity" min="0" max="100" value="80">
    </label>
    <small style="display:block;margin-top:6px;color:#555">
      Contours are colored dark red. Line width: <code>ID=1</code> (primary), <code>ID=2</code> (secondary).
    </small>
  </div>
  <hr>

  <input type="checkbox" id="dotsToggle"> <strong>Dot map</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Dot size (px): <span id="dotSizeLabel" class="control-value">1.9</span>
      <input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="1.9">
    </label>
    <label>Opacity (dots): <span id="dotsOpacityLabel" class="control-value">100%</span>
      <input type="range" id="dotsOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <input type="checkbox" id="boundariesToggle"> <strong>Municipal boundaries</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity (boundaries): <span id="boundariesOpacityLabel" class="control-value">100%</span>
      <input type="range" id="boundariesOpacity" min="0" max="100" value="100">
    </label>
  </div>
  <hr>

  <div style="font-size:12px;color:#555">
    <strong>Data notes (students)</strong><br>
    - All GeoJSONs are expected in <code>data/</code> relative to this HTML file.<br>
    - Fields used: <code>POPDENS</code> (choropleth), <code>POPMUN</code> (proportional circles), <code>Id</code> (contours).
  </div>
</div>

<div id="legend"></div>
<div id="map"></div>
<!-- ============================================================
     END OF HTML STRUCTURE SECTION
     ============================================================ -->

<!-- ============================================================
     JAVASCRIPT SECTION - APPLICATION LOGIC
     ============================================================ -->
<script>

/* üó∫Ô∏è STUDENTS - MODIFY MAP CENTER AND ZOOM */
const map = new maplibregl.Map({
  container: 'map',
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center: [22.4, 39.6],  // üó∫Ô∏è STUDENTS: Change [longitude, latitude] for your area
  zoom: 8                // üó∫Ô∏è STUDENTS: Adjust zoom level (0=world, 20=street)
});

/* üìÇ STUDENTS - MODIFY DATA FILE PATHS AND FIELD NAMES */
const layerDefinitions = {
  popdens: {
    sourceId: 'popdens-src',
    layerId: 'popdens-layer',
    url: 'data/dimoi_popdens_WGS.geojson',  // üìÇ STUDENTS: Change path to your file
    dataField: 'POPDENS'                     // üìÇ STUDENTS: Change field name to match your data
  },
  poipop: {
    sourceId: 'poipop-src',
    layerId: 'poipop-layer',
    url: 'data/dimoi_poi_pop_WGS.geojson',  // üìÇ STUDENTS: Change path to your file
    dataField: 'POPMUN',                     // üìÇ STUDENTS: Change field name to match your data
    maxValueApprox: 100000                   // üìä STUDENTS: Change to your max population value
  },
  contours: {
    sourceId: 'contours-src',
    layerId: 'contours-layer',
    url: 'data/pop_contours_200k_WGS.geojson'  // üìÇ STUDENTS: Change path to your file
  },
  dots: {
    sourceId: 'dots-src',
    layerId: 'dots-layer',
    url: 'data/pop_dots_300_WGS.geojson'  // üìÇ STUDENTS: Change path to your file
  },
  boundaries: {
    sourceId: 'boundaries-src',
    layerId: 'boundaries-layer',
    url: 'data/dimoi_oria_WGS.geojson'  // üìÇ STUDENTS: Change path to your file
  }
};

let popdensData = null;
const enabledLayers = { 
  popdens: false,
  poipop: false,
  contours: false,
  dots: false,
  boundaries: false
};

/* üé® STUDENTS - MODIFY CHOROPLETH COLOR SCHEMES */
const colorSchemes = {
  3: ['#ffcccc', '#ff6666', '#990000'],           // üé® STUDENTS: Change colors for 3-class scheme
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'], // üé® STUDENTS: Change colors for 4-class scheme
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'], // üé® STUDENTS: Change colors (default)
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
  
  // üé® Alternative color schemes you can use:
  // Blue: 5: ['#eff3ff', '#bdd7e7', '#6baed6', '#3182bd', '#08519c']
  // Green: 5: ['#edf8e9', '#bae4b3', '#74c476', '#31a354', '#006d2c']
};

function equalIntervalBreaks(sorted, n) {
  const min = sorted[0];
  const max = sorted[sorted.length-1];
  if (min === max) return [max];
  const step = (max - min) / n;
  const breaks = [];
  for (let i=1; i<n; i++) {
    breaks.push(min + step*i);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

function quantileBreaks(sorted, n) {
  const breaks = [];
  for (let i=1; i<n; i++){
    const idx = Math.floor((sorted.length * i)/n);
    breaks.push(sorted[Math.min(idx, sorted.length-1)]);
  }
  return breaks.map(b => Number(b.toFixed(2)));
}

function jenksBreaks(sorted, numClasses) {
  const n = sorted.length;
  const mat1 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));
  const mat2 = Array.from({length: n+1}, () => Array(numClasses+1).fill(0));

  for (let i=1; i<=numClasses; i++) {
    mat1[1][i] = 1;
    mat2[1][i] = 0;
    for (let j=2; j<=n; j++) {
      mat2[j][i] = Infinity;
    }
  }

  for (let l=2; l<=n; l++) {
    let s1=0, s2=0, w=0;
    for (let m=1; m<=l; m++) {
      const i3 = l - m + 1;
      const val = sorted[i3 - 1];
      s2 += val*val;
      s1 += val;
      w++;
      const v = s2 - (s1*s1)/w;
      const i4 = i3 - 1;
      if (i4 !== 0) {
        for (let j=2; j<=numClasses; j++){
          if (mat2[l][j] >= (v + mat2[i4][j-1])) {
            mat1[l][j] = i3;
            mat2[l][j] = v + mat2[i4][j-1];
          }
        }
      }
    }
    mat1[l][1] = 1;
    mat2[l][1] = mat2[l-1][1] + (sorted[l-1]-sorted[0])*(sorted[l-1]-sorted[0]);
  }

  const breaks = [];
  let k = n;
  for (let j = numClasses; j >= 2; j--) {
    const id = mat1[k][j] - 1;
    breaks.push(sorted[id]);
    k = mat1[k][j] - 1;
  }
  return breaks.reverse().map(b => Number(b.toFixed(2)));
}

function calculateBreaks(values, numClasses, method) {
  const sorted = values.filter(v => v != null && !isNaN(v)).sort((a,b)=>a-b);
  if (sorted.length === 0) return [];
  if (method === 'equal') return equalIntervalBreaks(sorted, numClasses);
  if (method === 'quantile') return quantileBreaks(sorted, numClasses);
  if (method === 'natural') return jenksBreaks(sorted, numClasses);
  return equalIntervalBreaks(sorted, numClasses);
}

function createStepExpression(breaks, colors, field='POPDENS') {
  const expr = ['step', ['get', field], colors[0]];
  for (let i=0; i<breaks.length; i++){
    expr.push(breaks[i]);
    expr.push(colors[i+1] || colors[colors.length-1]);
  }
  return expr;
}

function ensureSource(id, urlOrGeojson) {
  if (!map.getSource(id)) {
    map.addSource(id, { type: 'geojson', data: urlOrGeojson });
  } else {
    if (typeof urlOrGeojson === 'object') {
      map.getSource(id).setData(urlOrGeojson);
    }
  }
}

function applyPopDensClassification() {
  if (!popdensData) {
    console.warn('No popdensData cached.');
    return;
  }
  
  const method = document.getElementById('classificationMethod').value;
  const nclasses = parseInt(document.getElementById('numClasses').value,10);
  const colors = colorSchemes[nclasses] || colorSchemes[5];

  // üìÇ STUDENTS: Extract values using the dataField specified in layerDefinitions
  const values = popdensData.features.map(f => parseFloat(f.properties[layerDefinitions.popdens.dataField]));
  
  const breaks = calculateBreaks(values, nclasses, method);
  const expr = createStepExpression(breaks, colors, layerDefinitions.popdens.dataField);

  ensureSource(layerDefinitions.popdens.sourceId, popdensData);

  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  } else {
    map.addLayer({
      id: layerDefinitions.popdens.layerId,
      type: 'fill',
      source: layerDefinitions.popdens.sourceId,
      paint: {
        'fill-color': expr,
        'fill-opacity': parseInt(document.getElementById('popdensOpacity').value,10)/100
      }
    });
  }

  layerDefinitions.popdens.breaks = breaks;
  layerDefinitions.popdens.colors = colors;
  
  enabledLayers.popdens = true;
  document.getElementById('popdensControls').style.display = 'block';
  updateLegend();
}

function loadPopDensLayer() {
  fetch(layerDefinitions.popdens.url)
    .then(r => r.json())
    .then(gj => {
      popdensData = gj;
      applyPopDensClassification();
    })
    .catch(err => {
      console.error('Failed to load POPDENS:', err);
      alert('Error loading POPDENS geojson. Check path in layerDefinitions.popdens.url');
    });
}

function loadPoipopLayer() {
  const def = layerDefinitions.poipop;
  ensureSource(def.sourceId, def.url);

  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 100000;
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': 'rgba(255,0,0,0.25)',  // üé® STUDENTS: Change circle fill color
        'circle-radius': radiusExpr,
        'circle-opacity': parseInt(document.getElementById('poipopOpacity').value,10)/100,
        'circle-stroke-color': 'red',  // üé® STUDENTS: Change circle outline color
        'circle-stroke-width': 0.8
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
    map.setPaintProperty(def.layerId, 'circle-opacity', parseInt(document.getElementById('poipopOpacity').value,10)/100);
  }

  enabledLayers.poipop = true;
  document.getElementById('poipopControls').style.display = 'block';
  updateLegend();
}

function updatePoipopRadius() {
  const def = layerDefinitions.poipop;
  if (!map.getLayer(def.layerId)) return;
  
  const maxR = parseInt(document.getElementById('maxRadius').value,10);
  const vL = def.maxValueApprox || 100000;
  const radiusExpr = ['*', ['^', ['/', ['get', def.dataField], vL], 0.57], maxR];
  
  map.setPaintProperty(def.layerId, 'circle-radius', radiusExpr);
  updateLegend();
}

function loadContoursLayer() {
  const def = layerDefinitions.contours;
  ensureSource(def.sourceId, def.url);

  const widthExpr = ['case', ['==', ['get', 'ID'], 1], 3, 1.2];
  const color = '#8B0000';  // üé® STUDENTS: Change contour line color

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': color,
        'line-width': widthExpr,
        'line-opacity': parseInt(document.getElementById('contoursOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-width', widthExpr);
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('contoursOpacity').value,10)/100);
  }

  enabledLayers.contours = true;
  document.getElementById('contoursControls').style.display = 'block';
  updateLegend();
}

function loadDotsLayer() {
  const def = layerDefinitions.dots;
  ensureSource(def.sourceId, def.url);

  const dotSize = parseFloat(document.getElementById('dotSize').value);  // üî¥ STUDENTS: Default dot size
  const opacity = parseInt(document.getElementById('dotsOpacity').value,10)/100;

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'circle',
      source: def.sourceId,
      paint: {
        'circle-color': '#000000',  // üé® STUDENTS: Change dot color
        'circle-radius': dotSize,
        'circle-opacity': opacity
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'circle-radius', dotSize);
    map.setPaintProperty(def.layerId, 'circle-opacity', opacity);
  }

  enabledLayers.dots = true;
  document.getElementById('dotsControls').style.display = 'block';
  updateLegend();
}

function loadBoundariesLayer() {
  const def = layerDefinitions.boundaries;
  ensureSource(def.sourceId, def.url);

  if (!map.getLayer(def.layerId)) {
    map.addLayer({
      id: def.layerId,
      type: 'line',
      source: def.sourceId,
      paint: {
        'line-color': '#bbbbbb',  // üé® STUDENTS: Change boundary line color
        'line-width': 1,
        'line-opacity': parseInt(document.getElementById('boundariesOpacity').value,10)/100
      }
    });
  } else {
    map.setPaintProperty(def.layerId, 'line-opacity', parseInt(document.getElementById('boundariesOpacity').value,10)/100);
  }

  enabledLayers.boundaries = true;
  document.getElementById('boundariesControls').style.display = 'block';
  updateLegend();
}

function removeLayer(name) {
  const def = layerDefinitions[name];
  if (map.getLayer(def.layerId)) map.removeLayer(def.layerId);
  if (map.getSource(def.sourceId)) map.removeSource(def.sourceId);
  enabledLayers[name] = false;
  const c = document.getElementById(name + 'Controls');
  if (c) c.style.display = 'none';
  updateLegend();
}

document.getElementById('popdensToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPopDensLayer(); } else { removeLayer('popdens'); }
});

document.getElementById('classificationMethod').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('numClasses').addEventListener('change', () => {
  if (enabledLayers.popdens) applyPopDensClassification();
});

document.getElementById('popdensOpacity').addEventListener('input', (e) => {
  document.getElementById('popdensOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.popdens.layerId)) {
    map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('poipopToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadPoipopLayer(); } else { removeLayer('poipop'); }
});

document.getElementById('maxRadius').addEventListener('input', (e) => {
  document.getElementById('maxRadiusLabel').textContent = e.target.value;
  updatePoipopRadius();
});

document.getElementById('poipopOpacity').addEventListener('input', (e) => {
  document.getElementById('poipopOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.poipop.layerId)) {
    map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('contoursToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadContoursLayer(); } else { removeLayer('contours'); }
});

document.getElementById('contoursOpacity').addEventListener('input', (e) => {
  document.getElementById('contoursOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.contours.layerId)) {
    map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('dotsToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadDotsLayer(); } else { removeLayer('dots'); }
});

document.getElementById('dotSize').addEventListener('input', (e) => {
  document.getElementById('dotSizeLabel').textContent = e.target.value;
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
  }
});

document.getElementById('dotsOpacity').addEventListener('input', (e) => {
  document.getElementById('dotsOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.dots.layerId)) {
    map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('boundariesToggle').addEventListener('change', (e) => {
  if (e.target.checked) { loadBoundariesLayer(); } else { removeLayer('boundaries'); }
});

document.getElementById('boundariesOpacity').addEventListener('input', (e) => {
  document.getElementById('boundariesOpacityLabel').textContent = e.target.value + '%';
  if (map.getLayer(layerDefinitions.boundaries.layerId)) {
    map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value,10)/100);
  }
});

document.getElementById('basemapSelect').addEventListener('change', (e) => {
  const style = e.target.value;
  const enabledSnapshot = {...enabledLayers};
  map.setStyle(style);
  
  map.once('styledata', () => {
    for (const key in enabledSnapshot) {
      if (enabledSnapshot[key]) {
        if (key === 'popdens') {
          if (popdensData) { applyPopDensClassification(); } else { loadPopDensLayer(); }
        } else if (key === 'poipop') { loadPoipopLayer();
        } else if (key === 'contours') { loadContoursLayer();
        } else if (key === 'dots') { loadDotsLayer();
        } else if (key === 'boundaries') { loadBoundariesLayer(); }
      }
    }
  });
});

/* üìù STUDENTS - MODIFY LEGEND TITLE AND TEXT */
function updateLegend() {
  const legend = document.getElementById('legend');
  let html = '';

  /* üìù STUDENTS: Change the text below to customize your map title and credits */
  html += `
    <div class="legend-header">
      <div class="legend-map-title">THESSALY POPULATION</div>
      <div class="legend-subtitle">
        (Thematic maps based on 2021 population data from the Hellenic Statistical Authority)
      </div>
      <div class="legend-author">
        <strong>Produced by:</strong> Loukas Katikas<br>
        National Technical University of Athens (NTUA)<br>
        School of Rural, Surveying & Geoinformatics Engineering<br>
        Cartography Laboratory<br>
        Thematic Cartography, Academic Year 2025-2026
      </div>
    </div>
  `;

  if (enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    const breaks = layerDefinitions.popdens.breaks;
    const colors = layerDefinitions.popdens.colors;
    
    html += `<div class="legend-title">Population density (people / km¬≤)</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[0]}"></div><div>&lt; ${breaks[0]}</div></div>`;
    
    for (let i=0; i<breaks.length-1; i++){
      html += `<div class="legend-row"><div class="legend-color" style="background:${colors[i+1]}"></div><div>${breaks[i]} ‚Äì ${breaks[i+1]}</div></div>`;
    }
    
    html += `<div class="legend-row"><div class="legend-color" style="background:${colors[colors.length-1]}"></div><div>&gt; ${breaks[breaks.length-1]}</div></div>`;
    html += '<hr>';
  }

  /* üìä STUDENTS - MODIFY LEGEND CIRCLE SIZES */
  if (enabledLayers.poipop) {
    const maxR = parseInt(document.getElementById('maxRadius').value,10);
    const maxVal = layerDefinitions.poipop.maxValueApprox || 100000;
    
    // üìä STUDENTS: Change these values to match your data ranges
    const vSmall = 1000;     // Small municipality
    const vMed = 10000;      // Medium municipality
    const vMedLarge = 50000; // Medium-large municipality
    const vLarge = 100000;   // Large municipality
    
    const r1 = Math.max(2, Math.pow(vSmall / maxVal, 0.57) * maxR);
    const r2 = Math.max(2, Math.pow(vMed / maxVal, 0.57) * maxR);
    const r3 = Math.max(2, Math.pow(vMedLarge / maxVal, 0.57) * maxR);
    const r4 = Math.max(2, Math.pow(vLarge / maxVal, 0.57) * maxR);
    
    const svgHeight = Math.round(Math.max(r4*2 + 20, 140));
    const cx = 110;
    const baseY = svgHeight - 10;

    html += `<div class="legend-title">Municipal population (proportional circles)</div>`;
    html += `<div style="text-align:center"><svg width="240" height="${svgHeight}">`;
    
    html += `<circle cx="${cx}" cy="${baseY - r1}" r="${r1}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r1*2) - 4}" text-anchor="middle" font-size="11">1,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r2}" r="${r2}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r2*2) - 4}" text-anchor="middle" font-size="11">10,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r3}" r="${r3}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r3*2) - 4}" text-anchor="middle" font-size="11">50,000</text>`;
    html += `<circle cx="${cx}" cy="${baseY - r4}" r="${r4}" fill="rgba(255,0,0,0.25)" stroke="red" stroke-width="0.8"></circle>`;
    html += `<text x="${cx}" y="${baseY - (r4*2) - 4}" text-anchor="middle" font-size="11">100,000</text>`;
    // üé® STUDENTS: Change circle colors by modifying fill="rgba(...)" and stroke="..." above
    
    html += `</svg></div><hr>`;
  }

  if (enabledLayers.contours) {
    html += `<div class="legend-title">Population potential contours</div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="3"/></svg><div>Primary (Id = 1)</div></div>`;
    html += `<div class="legend-row"><svg class="legend-line"><line x1="0" y1="7" x2="40" y2="7" stroke="#8B0000" stroke-width="1.2"/></svg><div>Secondary (Id = 2)</div></div>`;
    // üé® STUDENTS: Change stroke="#8B0000" to modify contour line color in legend
    html += '<hr>';
  }

  if (enabledLayers.dots) {
    html += `<div class="legend-title">Dot density</div>`;
    html += `<div class="legend-row"><svg width="30" height="24"><circle cx="15" cy="12" r="${parseFloat(document.getElementById('dotSize').value)}" fill="#000"/></svg><div>1 dot = 500 people (example)</div></div>`;
    // üé® STUDENTS: Change fill="#000" for dot color and "500 people" to match your data
    html += '<hr>';
  }

  if (enabledLayers.boundaries) {
    html += `<div class="legend-row"><svg width="40" height="18"><line x1="0" y1="9" x2="40" y2="9" stroke="#bbbbbb" stroke-width="1"/></svg><div>Municipal boundaries</div></div>`;
    // üé® STUDENTS: Change stroke="#bbbbbb" for boundary line color in legend
  }

  if (html.length) {
    legend.innerHTML = html;
    legend.style.display = 'block';
  } else {
    legend.style.display = 'none';
  }
}

function showHideControls() {
  Object.keys(enabledLayers).forEach(k => {
    const checkbox = document.getElementById(k + 'Toggle');
    const controls = document.getElementById(k + 'Controls');
    if (!controls) return;
    controls.style.display = checkbox.checked ? 'block' : 'none';
  });
}

showHideControls();

const uiInputs = ['classificationMethod','numClasses','popdensOpacity','maxRadius','poipopOpacity','contoursOpacity','dotSize','dotsOpacity','boundariesOpacity'];
uiInputs.forEach(id => {
  const el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('input', () => { updateLegend(); });
});

['popdensToggle','poipopToggle','contoursToggle','dotsToggle','boundariesToggle'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    showHideControls();
    updateLegend();
  });
});

map.on('load', () => {});

console.log('Thessaly Cartography Viewer - Ready');
console.log('Data files expected in "data/" folder');
console.log(layerDefinitions);

</script>
<!-- ============================================================
     END OF JAVASCRIPT SECTION
     ============================================================ -->
</body>
</html>










